<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>사다리타기 (Interactive)</title>
  <style>
    :root{--line-color:#333;--rung-color:#1e90ff;--player-colors: #ff6b6b,#ffd93d,#6bcB77,#4d96ff,#9b59b6,#ff7ab6,#ff8c42,#2ecc71}
    body{font-family:Inter,system-ui,-apple-system,'Segoe UI',Roboto,'Noto Sans KR',sans-serif;display:flex;flex-direction:column;align-items:center;padding:18px;background:#f6f7fb;color:#222}
    h1{margin:6px 0 12px}
    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
    input[type=number]{width:64px;padding:6px}
    .players{display:flex;gap:8px;flex-wrap:wrap}
    .player-input{display:flex;gap:6px;align-items:center}
    button{background:#333;color:#fff;padding:8px 12px;border-radius:8px;border:0;cursor:pointer}
    button.secondary{background:#666}
    #boardWrap{background:white;padding:16px;border-radius:12px;box-shadow:0 6px 20px rgba(20,20,60,0.08);}
    svg{display:block;max-width:100%;height:500px}
    .result{margin-top:12px}
    .lane-labels{display:flex;justify-content:space-between;margin-top:8px}
    .player-badge{display:inline-block;padding:6px 8px;border-radius:999px;color:#fff;font-weight:600}
    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  </style>
</head>
<body>
  <h1>사다리타기 (Interactive)</h1>
  <div class="controls">
    <label>플레이어 수: <input id="playerCount" type="number" min="2" max="8" value="4"></label>
    <button id="setPlayers">플레이어 세팅</button>
    <button id="generate">사다리 생성</button>
    <button id="start" style="background: #1177dd">시작</button>
    <button id="randomizeNames" class="secondary">랜덤 이름</button>
  </div>

  <div class="players" id="playersArea"></div>

  <div id="boardWrap">
    <svg id="ladderSvg" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet"></svg>
    <div class="lane-labels" id="topLabels"></div>
    <div class="lane-labels" id="bottomLabels"></div>
  </div>

  <div class="result" id="resultArea"></div>

  <script>
    // 간단한 사다리타기 구현
    const maxPlayers = 8;
    const svg = document.getElementById('ladderSvg');
    const playerCountInput = document.getElementById('playerCount');
    const playersArea = document.getElementById('playersArea');
    const generateBtn = document.getElementById('generate');
    const setPlayersBtn = document.getElementById('setPlayers');
    const startBtn = document.getElementById('start');
    const resultArea = document.getElementById('resultArea');
    const randomizeNamesBtn = document.getElementById('randomizeNames');

    let playerCount = parseInt(playerCountInput.value,10);
    let players = [];
    let rungs = []; // horizontal connectors: {y, leftIndex}
    const svgW = 800, svgH = 600, margin = 80;

    const sampleNames = ['민수','지은','준호','서연','현우','지우','수빈','태현'];

    function createPlayerInputs(){
      playersArea.innerHTML = '';
      for(let i=0;i<playerCount;i++){
        const div = document.createElement('div');
        div.className = 'player-input';
        const input = document.createElement('input');
        input.value = players[i]?.name || (`Player ${i+1}`);
        input.dataset.index = i;
        input.addEventListener('input', e=> players[e.target.dataset.index].name = e.target.value);
        const color = document.createElement('span');
        color.className = 'player-badge';
        color.textContent = i+1;
        color.style.background = getPlayerColor(i);
        div.appendChild(color);
        div.appendChild(input);
        playersArea.appendChild(div);
      }
    }

    function initPlayers(){
      players = [];
      for(let i=0;i<playerCount;i++) players.push({name: sampleNames[i]||`P${i+1}`,index:i});
      createPlayerInputs();
    }

    function getPlayerColor(i){
      const colors = ['#ff6b6b','#ffd93d','#6bcB77','#4d96ff','#9b59b6','#ff7ab6','#ff8c42','#2ecc71'];
      return colors[i%colors.length];
    }

    function generateLadder(){
      // generate random rungs between adjacent lanes at random heights
      rungs = [];
      const lanes = playerCount;
      const rungCount = Math.floor(10 + Math.random()*12); // number of potential horizontal rungs
      const minY = margin, maxY = svgH - margin;
      const used = {}; // avoid adjacent overlaps
      for(let i=0;i<rungCount;i++){
        const left = Math.floor(Math.random()*(lanes-1));
        const y = Math.floor(minY + Math.random()*(maxY-minY));
        // avoid too-close rungs at same left index
        const key = `${left}`;
        if(!used[key]) used[key]=[];
        // ensure no y within 25px of existing rung on same left
        if(used[key].some(v=>Math.abs(v-y)<28)) continue;
        // also ensure we don't cross in adjacent rung positions at similar y
        if(left>0 && used[left-1] && used[left-1].some(v=>Math.abs(v-y)<20)) continue;
        if(left<lanes-2 && used[left+1] && used[left+1].some(v=>Math.abs(v-y)<20)) continue;
        used[key].push(y);
        rungs.push({leftIndex:left,y});
      }
      rungs.sort((a,b)=>a.y-b.y);
      drawLadder();
    }

    function drawLadder(){
      svg.innerHTML = '';
      const lanes = playerCount;
      const gap = (svgW - 2*margin)/(lanes-1);
      // vertical lines
      for(let i=0;i<lanes;i++){
        const x = margin + i*gap;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',x); line.setAttribute('y1',margin); line.setAttribute('x2',x); line.setAttribute('y2',svgH-margin);
        line.setAttribute('stroke','#333'); line.setAttribute('stroke-width',3);
        svg.appendChild(line);
      }
      // rungs
      rungs.forEach(r=>{
        const x1 = margin + r.leftIndex*gap;
        const x2 = margin + (r.leftIndex+1)*gap;
        const y = r.y;
        const rung = document.createElementNS('http://www.w3.org/2000/svg','line');
        rung.setAttribute('x1',x1); rung.setAttribute('x2',x2); rung.setAttribute('y1',y); rung.setAttribute('y2',y);
        rung.setAttribute('stroke','#1e90ff'); rung.setAttribute('stroke-width',6); rung.setAttribute('stroke-linecap','round');
        svg.appendChild(rung);
      });

      // labels
      const topLabels = document.getElementById('topLabels');
      const bottomLabels = document.getElementById('bottomLabels');
      topLabels.innerHTML = '';
      bottomLabels.innerHTML = '';
      for(let i=0;i<lanes;i++){
        const spanTop = document.createElement('div');
        spanTop.style.flex = '1';
        spanTop.style.textAlign = (i===0)?'left':(i===lanes-1)?'right':'center';
        spanTop.textContent = players[i].name;
        spanTop.style.fontWeight = '700';
        topLabels.appendChild(spanTop);

        const spanBot = document.createElement('div');
        spanBot.style.flex = '1';
        spanBot.style.textAlign = (i===0)?'left':(i===lanes-1)?'right':'center';
        spanBot.textContent = `결과 ${i+1}`;
        bottomLabels.appendChild(spanBot);
      }
    }

    function followPath(startIndex){
      // simulate following rungs top->bottom
      let pos = startIndex;
      const path = [{x:pos,y:margin}];
      const lanes = playerCount; const gap = (svgW - 2*margin)/(lanes-1);
      // iterate through rungs in order
      rungs.forEach(r=>{
        if(r.leftIndex === pos){
          // move right
          path.push({x:pos,y:r.y});
          pos = pos+1;
          path.push({x:pos,y:r.y});
        } else if(r.leftIndex === pos-1){
          // move left (rung connects pos-1 and pos)
          path.push({x:pos,y:r.y});
          pos = pos-1;
          path.push({x:pos,y:r.y});
        }
      });
      path.push({x:pos,y:svgH-margin});
      // convert lane positions to coordinates
      const coords = path.map(p=> ({cx: margin + p.x*gap, cy: p.y}));
      return {finalIndex: pos, coords};
    }

    function animateAll(){
      resultArea.innerHTML = '';
      const lanes = playerCount;
      const promises = players.map((pl,i)=> animatePlayer(i,pl));
      Promise.all(promises).then(results=>{
        // show final order by bottom slot index
        const ranking = results.map((r,i)=> ({name:players[i].name, final:r.finalIndex})).sort((a,b)=>a.final-b.final);
        const ul = document.createElement('div');
        ul.innerHTML = '<strong>결과:</strong> ' + ranking.map((r,idx)=>`<div style="margin-top:6px"><span class="player-badge" style="background:${getPlayerColor(idx)};margin-right:8px">${idx+1}</span>${r.name} → 칸 ${r.final+1}</div>`).join('');
        resultArea.appendChild(ul);
      });
    }

    function animatePlayer(index,player){
      return new Promise(resolve=>{
        const {finalIndex, coords} = followPath(index);
        // draw a circle and animate through coords
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r',12);
        circle.setAttribute('fill', getPlayerColor(index));
        circle.setAttribute('cx',coords[0].cx);
        circle.setAttribute('cy',coords[0].cy - 18);
        svg.appendChild(circle);
        // animate using simple step timing
        let step = 0;
        function stepAnim(){
          if(step >= coords.length){
            // settle to bottom label position
            circle.setAttribute('cx', margin + finalIndex * ((svgW - 2*margin)/(playerCount-1)));
            circle.setAttribute('cy', svgH - margin + 28);
            setTimeout(()=>{ resolve({finalIndex}); }, 300);
            return;
          }
          const c = coords[step];
          // move to c with small animation
          const startX = parseFloat(circle.getAttribute('cx'));
          const startY = parseFloat(circle.getAttribute('cy'));
          const dx = c.cx - startX;
          const dy = c.cy - 18 - startY;
          const frames = 12;
          let f = 0;
          const t = setInterval(()=>{
            f++;
            const ix = startX + dx*(f/frames);
            const iy = startY + dy*(f/frames);
            circle.setAttribute('cx', ix);
            circle.setAttribute('cy', iy);
            if(f>=frames){ clearInterval(t); step++; setTimeout(stepAnim, 80); }
          }, 18 + Math.random()*12);
        }
        // stagger delay so animations don't perfectly overlap
        setTimeout(stepAnim, index*220);
      });
    }

    // init
    setPlayersBtn.addEventListener('click', ()=>{
      playerCount = Math.max(2, Math.min(maxPlayers, parseInt(playerCountInput.value,10)||2));
      initPlayers();
    });
    generateBtn.addEventListener('click', ()=>{
      generateLadder();
      resultArea.innerHTML = '';
    });
    startBtn.addEventListener('click', ()=>{
      if(rungs.length===0) generateLadder();
      animateAll();
    });
    randomizeNamesBtn.addEventListener('click', ()=>{
      for(let i=0;i<playerCount;i++) players[i].name = sampleNames[i] || `P${i+1}`;
      createPlayerInputs();
    });

    // initial setup
    initPlayers();
    generateLadder();
  </script>
</body>
</html>
